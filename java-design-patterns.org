#+TIILE: Java Design Patterns

* java设计模式

** 源码地址：我的github账号

** 策略模式 Strategy

*** 例子

    鸭子，不同行为不同颜色等

*** 原理

    分别实现行为接口，实现算法族，超类里放行为接口对象，在子类里具体设置行为接口对象。
    
*** 原则

    分离变化部分，封装接口，基于接口编程各种功能。此模式让行为算法的变化独立于算法的使用者

*** 注意点： 

    1. 分析变化部分和不变部分
   
    2. 多用组合少用继承；用行为类组合，而不是行为的继承，更有弹性
   
** 观察者模式 Observer

*** 例子

    天气预报

*** 原理

    在对象之间定义了一对多的依赖，当一个对象改变状态，依赖它的对象会收到通知并自动更新。
    
*** jdk实现

    1. Observable **类** 对于观察者注册、删除、提醒等操作， 设置一个主题，这个主题继承这个抽象类
    
    2. ~注意~ 在调用通知事件的时候需要设置changed，可以看看源码，如下：
    
       #+BEGIN_SRC java
         if (!changed)
             return;
         arrLocal = obs.toArray();
       #+END_SRC

    3. Observer **接口**  观察者实现的接口
    
** 装饰者模式 Decorator

*** 例子
    
    咖啡馆订单系统

*** 原理

    装饰者模式可以动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。 ~超类传递~

*** 适用环境

    1. 装饰者模式可以动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。
    
    2. 处理那些可以撤消的职责。

    3. 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。

*** 实现关键

    1. Component（被装饰对象基类）：定义对象的接口，可以给这些对象动态增加职责； ~顶级超类，所有实现直接或者间接的继承了该类，并对其方法进行扩展；充分利用了继承的优势~

    2. ConcreteComponent（具体被装饰对象）：定义具体的对象，Decorator可以给它增加额外的职责； ~所有要实现的具体的对象，即各个主体Subject的实现~

    3. Decorator（装饰者抽象类）：维护指向Component实例的引用，定义与Component一致的接口（也就是要继承或实现被装饰对象基类）； ~继承超类的顶级装饰者类~

    4. ConcreteDecorator（具体装饰者）：具体的装饰对象，给内部持有的具体被装饰对象增加具体的职责； ~具体装饰者中都有顶级超类（被装饰者）的属性，便于完成递归的操作~

*** Java中的装饰者模式 

    InputStream -> fileInputStream StringBufferInputStream ByteArrayInputStream filterInputStream

    FilterInputStream -> bufferedInputStream DataInputStream LineNumberInputStream

*** 用法

    new Object(new Object())   类中参数为类，他们有共同的上级父类

*** 关键点

    梳理出主体和装饰者， 开放和关闭的原则，添加新代码（功能）的开放，对已经测试好的代码的修改是关闭的

** 单例模式 Singleton

*** 原理

    有些对象只需要一个，如：线程池、缓存、硬件等

    如果多个实例会导致冲突、结果的不一致性等问题

    确保一个类最多只有一个实例，并提供一个全局访问点

*** 原则

    私有化构造函数

    静态成员变量、静态方法

*** 场景

    如果一个对象只能有一个，进行各项操作，那么就需要对他进行控制。

*** 严谨的方法

    1. 静态成员变量声明为 static volatile 保证内存可见性、防止指令重排序

       Double Check

    #+BEGIN_SRC java
    if(obj == null) {
      synchronized(this) {
          if (obj == null ) {
              obj = new Object();
          }
      }
    }
    #+END_SRC

    2. 静态变量上直接new 对象
    
** 工厂模式 Factory

*** 简单工厂模式

**** 特点

     1. 工厂类是一个具体的类，内部有一个create方法，利用if或switch创建产品并返回

     2. create方法通常是静态的，称之为静态工厂模式

**** 缺点

     1. 扩展性差，如果新增一个产品需要修改其代码

     2. 不同产品需要不同额外参数的时候，不支持
   
*** 工厂方法模式

**** 原理

     实现一个创建对象的接口（工厂接口），让其实现类（工厂实现类）决定实例化哪个类（产品类），并且由该实现类常见对应类的实例

**** 作用

     可以一定程度上解耦，消费者和产品实现类隔离开，只依赖产品接口(抽象产品)，产品实现类如何改动与消费者完全无关。

     可以一定程度增加扩展性，若增加一个产品实现，只需要实现产品接口，修改工厂创建产品的方法，消费者可以无感知（若消费者不关心具体产品是什么的情况）。
     
     可以一定程度增加代码的封装性、可读性。清楚的代码结构，对于消费者来说很少的代码量就可以完成很多工作。

     另外，抽象工厂才是实际意义的工厂模式，工厂方法只是抽象工厂的一个比较常见的情况。

**** 适用场景

     消费者不关心它所要创建对象的类(产品类)的时候。

     消费者知道它所要创建对象的类(产品类)，但不关心如何创建的时候。

     例如：hibernate里通过sessionFactory创建session、通过代理方式生成ws客户端时，通过工厂构建报文中格式化数据的对象。

**** 实现要点    

     1. 提供一个产品类的接口。产品类均要实现这个接口(也可以是abstract类，即抽象产品)。

     2. 提供一个工厂类的接口。工厂类均要实现这个接口(即抽象工厂)。

     3. 由工厂实现类创建产品类的实例。工厂实现类应有一个方法，用来实例化产品类。

**** 参考理解

     https://www.cnblogs.com/zailushang1996/p/8601808.html

*** 抽象工厂模式

**** 原理

     1. 创建工厂接口和产品类接口

     2. 工厂接口中有对应产品类接口的返回值

     3. 工厂实现类实现工厂接口，并实现起方法

     4. ~注意~ 工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类，而抽象工厂模式所提供的产品则是衍生自不同的接口或抽象类。

**** 优点

        抽象工厂模式除了具有工厂方法模式的优点外，最主要的优点就是可以在类的内部对产品族进行约束。所谓的产品族，一般或多或少的都存在一定的关联，抽象工厂模式就可以在类内部对产品族的关联关系进行定义和描述，
        而不必专门引入一个新的类来进行管理。

**** 缺点

       产品族的扩展将是一件十分费力的事情，假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。所以使用抽象工厂模式时，对产品等级结构的划分是非常重要的。

**** 适用场景

       当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。说的更明白一点，就是一个继承体系中，如果存在着多个等级结构（即存在着多个抽象类），
       并且分属各个等级结构中的实现类之间存在着一定的关联或者约束，就可以使用抽象工厂模式。假如各个等级结构中的实现类之间不存在关联或约束，则使用多个独立的工厂来对产品进行创建，则更合适一点。

** 命令模式 Command

*** 原理

    将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化；对请求排队或记录日志，以及支持可撤销的操作，将”发出请求的对象”和”接收与执行这些请求的对象”分隔开来。

*** 实现

    1. 定义命令接口，声明需要完成的行为接口

    2. 命令接口的实现类，将接受者作为全局变量

    3. 定义接收者， 接收者完成自己需要实现的功能，包含但不限于命令接口中的方法

    4. 定义暴露者， 暴露者根据具体的全局变量类型执行对应的方法

** 适配器模式 Adaptor

*** 类适配器

**** 原理

     通过继承的方式来实现适配器

**** 白话

     对原有对象插拔接口，实现适配功能

**** 实例讲解

     我手中有个ps2插头的设备，但是主机上只有usb插头的插口，怎么办呢？弄个转换器，将ps2插头转换成为USB插头就可以使用了。

     　　1. 接口Ps2：描述ps2接口格式

     　　2. 接口Usb：描述USB接口格式

     　　3. 类Usber：是接口Usb的实现类，是具体的USB接口格式

     　　4. Adapter：用于将ps2接口格式转换成为USB接口格式

*** 对象适配器

**** 原理

     通过组合来实现适配器功能

**** 白话

     添加一个中间类实现接口A，在该类中添加B接口的实现类作为参数，在重写A接口方法中调用B接口实现类的方法

**** 实例讲解

     我手中有个ps2插头的设备，但是主机上只有usb插头的插口，怎么办呢？弄个转换器，将ps2插头转换成为USB插头就可以使用了。

     　　1. 接口Ps2：描述ps2接口格式

     　　2. 接口Usb：描述USB接口格式

     　　3. 类Usber：是接口Usb的实现类，是具体的USB接口格式

     　　4. Adapter：用于将ps2接口格式转换成为USB接口格式

*** 接口适配器

**** 原理
     
     通过抽象类来实现适配，这种适配稍别于上面所述的适配

     当存在这样一个接口，其中定义了N多的方法，而我们现在却只想使用其中的一个到几个方法，如果我们直接实现接口，那么我们要对所有的方法进行实现，
     哪怕我们仅仅是对不需要的方法进行置空（只写一对大括号，不做具体方法实现）也会导致这个类变得臃肿，调用也不方便，这时我们可以使用一个抽象类作为中间件，
     即适配器，用这个抽象类实现接口，而在抽象类中所有的方法都进行置空，那么我们在创建抽象类的继承类，而且重写我们需要使用的那几个方法即可。

**** 白话

     其实就是防止代码的臃肿，过滤掉我们不需要的方法

*** 适配器模式的适用场景

**** 类适配器和对象适配器 

     1. 想要使用一个已经存在的类，但是它却不符合现有的接口规范，导致无法直接去访问，这时创建一个适配器就能间接去访问这个类中的方法。

　　 2. 我们有一个类，想将其设计为可重用的类（可被多处访问），我们可以创建适配器来将这个类来适配其他没有提供合适接口的类。

　　 以上两个场景其实就是从两个角度来描述一类问题，那就是要 ~访问的方法不在合适的接口里，一个从接口出发（被访问），一个从访问出发（主动访问）。~

**** 接口适配器

     想要使用接口中的某个或某些方法，但是接口中有太多方法，我们要使用时必须实现接口并实现其中的所有方法，可以使用抽象类来实现接口，
     并不对方法进行实现（仅置空），然后我们再继承这个抽象类来通过重写想用的方法的方式来实现。这个抽象类就是适配器。

** 外观模式 Facade

*** 概念

    外观模式（Facade）,他隐藏了系统的复杂性，并向客户端提供了一个可以访问系统的接口。这种类型的设计模式属于结构性模式。为子系统中的一组接口提供了一个统一的访问接口，这个接口使得子系统更容易被访问或者使用。 

*** 原理

    1. 门面角色：外观模式的核心。它被客户角色调用，它熟悉子系统的功能。内部根据客户角色的需求预定了几种功能的组合。

    2. 子系统角色:实现了子系统的功能。它对客户角色和Facade时未知的。它内部可以有系统内的相互交互，也可以由供外界调用的接口。

　　3. 客户角色:通过调用Facede来完成要实现的功能。

*** 白话

    在Facade类中，详细知道子系统的实现功能， 对子系统中的功能进行组合运用

*** 例子

    Computer和CPU、Memory、Disk之间的关系

    我们常用的业务层代码，就是这种模式

*** 使用场景

    1. 为复杂的模块或子系统提供外界访问的模块；

　　2. 子系统相互独立；

　　3. 在层析结构中，可以使用外观模式定义系统的每一层的入口。

*** 优点

    1. 松散耦合

       使得客户端和子系统之间解耦，让子系统内部的模块功能更容易扩展和维护；

    2. 简单易用

       客户端根本不需要知道子系统内部的实现，或者根本不需要知道子系统内部的构成，它只需要跟Facade类交互即可。

    3. 更好的划分访问层次

       有些方法是对系统外的，有些方法是系统内部相互交互的使用的。子系统把那些暴露给外部的功能集中到门面中，这样就可以实现客户端的使用，很好的隐藏了子系统内部的细节。

** 模版模式 Template

*** 定义

    模板方法模式是类的行为模式。准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。
    不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。这就是模板方法模式的用意

*** 原理

    模板方法模式是所有模式中最为常见的几个模式之一，是基于继承的代码复用的基本技术。

*** 两个重要角色

**** 抽象模板(Abstract Template)角色有如下责任：

　　■　　定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。

　　■　　定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。

**** 具体模板(Concrete Template)角色又如下责任：

　　■　　实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。

　　■　　每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。

*** 关键 

    子类可以置换掉父类的可变部分，但是子类却不可以改变模板方法所代表的顶级逻辑。

　　每当定义一个新的子类时，不要按照控制流程的思路去想，而应当按照“责任”的思路去想。换言之，应当考虑哪些操作是必须置换掉的，哪些操作是可以置换掉的，以及哪些操作是不可以置换掉的。使用模板模式可以使这些责任变得清晰。

*** 模版方法模式中的方法

**** 模版方法

     一个模板方法是定义在抽象类中的，把基本操作方法组合在一起形成一个总算法或一个总行为的方法。

　　 一个抽象类可以有任意多个模板方法，而不限于一个。每一个模板方法都可以调用任意多个具体方法。

**** 基本方法

     基本方法又可以分为三种：抽象方法(Abstract Method)、具体方法(Concrete Method)和钩子方法(Hook Method)。

　　●　　抽象方法：一个抽象方法由抽象类声明，由具体子类实现。在Java语言里抽象方法以abstract关键字标示。 

　　●　　具体方法：一个具体方法由抽象类声明并实现，而子类并不实现或置换。 private

　　●　　钩子方法：一个钩子方法由抽象类声明并实现，而子类会加以扩展。通常抽象类给出的实现是一个空实现，作为方法的默认实现。 protected

**** 默认钩子方法

***** 介绍

      一个钩子方法常常由抽象类给出一个空实现作为此方法的默认实现。这种空的钩子方法叫做“Do Nothing Hook”。显然，这种默认钩子方法在缺省适配模式里面已经见过了，一个缺省适配模式讲的是一个类为一个接口提供一个默认的空实现，
      从而使得缺省适配类的子类不必像实现接口那样必须给出所有方法的实现，因为通常一个具体类并不需要所有的方法。

***** 命名规则

      钩子方法的名字应当以do开始，这是熟悉设计模式的Java开发人员的标准做法。在上面的例子中，钩子方法hookMethod()应当以do开头；在HttpServlet类中，也遵从这一命名规则，如doGet()、doPost()等方法。

*** 示例

    模板方法模式在Servlet中的应用

    使用过Servlet的人都清楚，除了要在web.xml做相应的配置外，还需继承一个叫HttpServlet的抽象类。HttpService类提供了一个service()方法，这个方法调用七个do方法中的一个或几个，完成对客户端调用的响应。
    这些do方法需要由HttpServlet的具体子类提供，因此这是典型的模板方法模式。下面是service()方法的源代码：

    #+BEGIN_SRC java
     protected void service(HttpServletRequest req, HttpServletResponse resp)
        throws ServletException, IOException {

        String method = req.getMethod();

        if (method.equals(METHOD_GET)) {
            long lastModified = getLastModified(req);
            if (lastModified == -1) {
                // servlet doesn't support if-modified-since, no reason
                // to go through further expensive logic
                doGet(req, resp);
            } else {
                long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);
                if (ifModifiedSince < (lastModified / 1000 * 1000)) {
                    // If the servlet mod time is later, call doGet()
                    // Round down to the nearest second for a proper compare
                    // A ifModifiedSince of -1 will always be less
                    maybeSetLastModified(resp, lastModified);
                    doGet(req, resp);
                } else {
                    resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
                }
            }

        } else if (method.equals(METHOD_HEAD)) {
            long lastModified = getLastModified(req);
            maybeSetLastModified(resp, lastModified);
            doHead(req, resp);

        } else if (method.equals(METHOD_POST)) {
            doPost(req, resp);
            
        } else if (method.equals(METHOD_PUT)) {
            doPut(req, resp);        
            
        } else if (method.equals(METHOD_DELETE)) {
            doDelete(req, resp);
            
        } else if (method.equals(METHOD_OPTIONS)) {
            doOptions(req,resp);
            
        } else if (method.equals(METHOD_TRACE)) {
            doTrace(req,resp);
            
        } else {
            //
            // Note that this means NO servlet supports whatever
            // method was requested, anywhere on this server.
            //

            String errMsg = lStrings.getString("http.method_not_implemented");
            Object[] errArgs = new Object[1];
            errArgs[0] = method;
            errMsg = MessageFormat.format(errMsg, errArgs);
            
            resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);
        }
    }
    #+END_SRC

** 迭代器模式 Iterator

*** Iterable接口和Iterator接口

    这两个都是迭代相关的接口，可以这么认为，实现了Iterable接口，则表示某个对象是可被迭代的；Iterator接口相当于是一个迭代器，实现了Iterator接口，等于具体定义了这个可被迭代的对象时如何进行迭代的。

    因为Iterator接口的核心方法next()或者hasNext()都是依赖于迭代器的当前迭代位置的。如果Collection直接实现Iterator接口，势必导致集合对象中包含当前迭代位置的数据，当集合在不同方法间被传递时，

    由于当前迭代位置不可预置，那么next()方法的结果会变成不可预知的。除非再为Iterator接口添加一个reset()方法，用来重置当前迭代位置。但即使这样，Collection也同时只能存在一个当前迭代位置。

    而Iterable，每次调用都返回一个从头开始计数的迭代器，多个迭代器时互不干扰。

*** 优点

    1、简化了便利方式，对于对象集合的遍历，还是比较麻烦的，对于数组或者有序列表，我们还可以通过下标来获取，但用户需要在对集合很了解的情况下，
       才能自行遍历对象（有时即使你了解了集合，还未必能直接遍历，比如上面的HashSet就没有提供get方法）。而引入了迭代器方法后，用户用起来就简单地多了

    2、可以供多种遍历方式，比如对于有序列表，可以正向遍历也可以倒序遍历，只要迭代器实现得好

    3、封装性好，用户只需要得到迭代器就可以遍历，而对于遍历算法则不用去关心

*** 缺点

    对于比较简单的遍历（数组或者有序列表），使用迭代器方式遍历较为繁琐而且遍历效率不高，使用迭代器的方式比较适合那些底层以链表形式实现的集合

*** 参考
    
    https://www.cnblogs.com/zhihyuan0420/articles/5684603.html

** 组合模式 Composite

*** 参考

    https://www.cnblogs.com/lfxiao/p/6816026.html

*** 定义

    组合多个对象形成树形结构以表示具有“整体—部分”关系的层次结构。

    组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性，组合模式又可以称为“整体—部分”(Part-Whole)模式，它是一种对象结构型模式。

*** 组合模式的几个角色

**** Component（抽象构件）

     它可以是接口或抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。在抽象构件中定义了访问及管理它的子构件的方法，如增加子构件、删除子构件、获取子构件等。

**** Leaf（叶子构件）

     它在组合结构中表示叶子节点对象，叶子节点没有子节点，它实现了在抽象构件中定义的行为。对于那些访问及管理子构件的方法，可以通过异常等方式进行处理。

**** Composite（容器构件）

     它在组合结构中表示容器节点对象，容器节点包含子节点，其子节点可以是叶子节点，也可以是容器节点，它提供一个集合用于存储子节点，实现了在抽象构件中定义的行为，

     包括那些访问及管理子构件的方法，在其业务方法中可以递归调用其子节点的业务方法。

*** 阐述 

     组合模式的关键是定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。

     同时容器对象与抽象构件类之间还建立一个聚合关联关系，在容器对象中既可以包含叶子，也可以包含容器，以此实现递归组合，形成一个树形结构。

     如果不使用组合模式，客户端代码将过多地依赖于容器对象复杂的内部实现结构，容器对象内部实现结构的变化将引起客户代码的频繁变化，带来了代码维护复杂、可扩展性差等弊端。

     组合模式的引入将在一定程度上解决这些问题。

*** 关键点

    1. 作为抽象构件类的子类，在叶子构件中需要实现在抽象构件类中声明的所有方法，包括业务方法以及管理和访问子构件的方法，但是叶子构件不能再包含子构件，因此在叶子构件中实现子构件管理和访问方法时需要提供异常处理或错误提示

    2. 在容器构件中实现了在抽象构件中声明的所有方法，既包括业务方法，也包括用于访问和管理成员子构件的方法，如add()、remove()和getChild()等方法。需要注意的是在实现具体业务方法时，由于容器构件充当的是容器角色，包含成员构件，

        因此它将调用其成员构件的业务方法。 在组合模式结构中，由于容器构件中仍然可以包含容器构件，因此在对容器构件进行处理时需要使用递归算法

***  透明组合模式与安全组合模式

**** 透明组合模式

     透明组合模式中，抽象构件Component中 ~声明了所有用于管理成员对象的方法~ ，包括add()、remove()以及getChild()等方法，这样做的好处是 ~确保所有的构件类都有相同的接口。~

     在客户端看来，叶子对象与容器对象所提供的方法是一致的，客户端可以相同地对待所有的对象。透明组合模式也是组合模式的标准形式

**** 安全组合模式

      安全组合模式中，在抽象构件Component中没有声明任何用于管理成员对象的方法，而是在Composite类中声明并实现这些方法。这种做法是安全的，因为根本不向叶子对象提供这些管理成员对象的方法，对于叶子对象，客户端不可能调用到这些方法

** 状态模式 States

*** 参考
  
    https://www.cnblogs.com/ZhangHaoShuaiGe/p/8000451.html

*** 原理

    状态模式允许一个对象在其内部状态改变的时候改变其行为。这个对象看上去就像是改变了它的类一样。

    状态模式适用于某一个对象的行为取决于该对象的状态，并且该对象的状态会在运行时转换，又或者有很多的if else判断，而这些判断只是因为状态不同而不断的切换行为。

*** 状态模式和策略模式的区别

    状态模式：将一群行为封装到状态对象中，context的行为随时可委托到那些状态对象中的一个。随着时间的流逝，当前状态在状态对象集合中游走改变，以反映出context内部的状态，因此，context的行为也会跟着改变。
    但是context的客户对于状态对象了解不多，甚至根本是浑然不觉。

    而以策略模式而言，客户通常主动指定Context所要组合的策略对象是哪一个。现在，固然策略模式让我们具有弹性，能够在运行时改变策略，但对于某个context对象来说，通常都只有一个最适当的策略对象。

*** 状态模式的要点

    1. 状态模式允许一个对象基于内部状态而拥有不同的行为。

    2. 状态模式用类代表状态

    3. Context会将行为委托给当前状态对象

    4. 通过将每个状态封装进一个类，我们把以后需要做的任何改变局部化了

    5. 状态模式和策略模式有相同的类图，但是它们的意图不同

    6. 策略模式通常会用行为或算法来配置Context类

    7. 状态模式允许Context随着状态的改变而改变行为

    8. 状态转换可以由State类或Context类控制。

    9. 使用状态模式通常会导致设计中类的数目大量增加。

    10. 状态类可以被多个Context实例共享。

** 代理模式 Proxy
    
*** 扩展

    Spring框架是时下很流行的Java开源框架，Spring之所有如此流行，跟它自身的特性是分不开的。Spring本身含有两大特性，一个是IOC，一个是AOP的支持。

    IOC是Inverse Of Control，即控制反转，也有人把IOC称作依赖注入。我觉得依赖注入这种说法很好理解，但不完全对。依赖注入是Dependency Injection的缩写，是实现IOC的一种方法，但不等同于IOC，IOC是一种思想，DI只是一种实现。

    AOP是Aspect Oriented Programming的缩写，即面向切面编程。与面向过程和面向对象的编程方式相比，面向切面编程提供了一种全新的思路，解决了OOP编程过程中的一些痛点。

    IOC的实现原理是利用了JAVA的反射技术，那么AOP的实现原理是什么呢？动态代理技术目前动态代理技术主要分为Java自己提供的JDK动态代理技术和CGLIB技术。Java自带的JDK动态代理技术是需要接口的，而CGLIB则是直接修改字节码。

*** java 的三种代理模式

**** 静态代理

***** 概念 

      是指具有与被代理对象相同的接口的类，客户端必须通过代理与被代理的目标类进行交互，而代理一般在交互的过程中（交互前后），进行某些特定的处理。

***** 要点

    1. 抽象对象角色：声明了目标类及代理类对象的共同接口，这样在任何可以使用目标对象的地方都可以使用代理对象。

    2. 目标对象角色：定义了代理对象所代表的目标对象。

    3. 代理对象角色 代理对象内部含有目标对象的引用，从而可以在任何时候操作目标对象；代理对象和目标对象具有统一的接口，以便可以再任何时候替代目标对象。

       代理对象通常在客户端调用传递给目标对象之前或者之后，执行某些操作，而非单纯的将调用传递给目标对象。

***** 使用场景

      如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法：

      （1）修改原有的方法来适应。显然这违反了“对扩展开放，对修改关闭”的原则。

      （2）采用一个代理类调用原来的方法，且对产生的结果进行控制。这就是代理模式了。

      使用代理模式可以将功能划分的更加清晰，有助于后期的维护。

      以上所说的这种代理模式称为静态代理。

***** 缺点

      因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护.

**** 动态代理

***** 特点

      1. 代理对象,不需要实现接口

      2. 代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)

      3. 动态代理也叫做:JDK代理,接口代理

***** JDk中生成代理对象的API

      代理类所在包 =java.lang.reflect.Proxy=

      JDK实现代理只需要使用newProxyInstance方法,但是该方法需要接收三个参数,完整的写法是:

      =static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces,InvocationHandler h )=

      注意该方法是在Proxy类中是静态方法,且接收的三个参数依次为:

      1. =ClassLoader loader= :指定当前目标对象使用类加载器,获取加载器的方法是固定的

      2. =Class<?>[] interfaces= :目标对象实现的接口的类型,使用泛型方式确认类型

      3. =InvocationHandler h= :事件处理,执行目标对象的方法时,会触发事件处理器的方法,会把当前执行目标对象的方法作为参数传入

***** 重点

      代理对象不需要实现接口,但是目标对象一定要实现接口,否则不能用动态代理

***** 关键代码

      #+BEGIN_SRC java
        Proxy.newProxyInstance(iUserService.getClass().getClassLoader(),
                        iUserService.getClass().getInterfaces(),
                        new InvocationHandler() {
                            @Override
                            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                                //执行目标对象方法
                                System.out.println("proxy class type is : " + proxy.getClass().getSimpleName());
                                System.out.println("method name is : " + method.getName());
                                // returnValue 是具体执行方法的
                                // invoke的第一个参数需要是我们的目标对象，而不是InvocationHandler中重写方法的第一个参数，否则出现循环导致报错
                                Object returnValue = method.invoke(iUserService, args);
                                return returnValue;
                            }
                        });
      #+END_SRC

**** Cglib代理
     
***** 简介

      静态代理和动态代理模式都是 ~要求目标对象是实现一个接口的目标对象~ ,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候就可以 ~使用以目标对象子类的方式类实现代理~ ,这种方法就叫做:Cglib代理

      Cglib代理,也叫作子类代理,它是在内存中 ~构建一个子类对象从而实现对目标对象功能的扩展.~

      JDK的动态代理有一个限制,就是使用动态代理的对象必须实现一个或多个接口, ~如果想代理没有实现接口的类,就可以使用Cglib实现.~

      Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口.它广泛的被许多AOP的框架使用,例如Spring AOP和synaop,为他们提供方法的interception(拦截)

      Cglib包的底层是通过使用一个小而块的字节码处理框架ASM来转换字节码并生成新的类.不鼓励直接使用ASM,因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉.

***** 要点

      Cglib子类代理实现方法:

      1. 需要引入cglib的jar文件,但是Spring的核心包中已经包括了Cglib功能,所以直接引入 =spring-core-3.2.5.jar= 即可.

      2. 引入功能包后,就可以在内存中动态构建子类

      3. 代理的类不能为final,否则报错

      4. 目标对象的方法如果为final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法.

***** 关键代码

      #+BEGIN_SRC java
      
     public Object cglibProxyInstance() {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(target.getClass());
        // 使用this的话，需要让当前是CallBack的实现类，实现MethodInterceptor接口
        enhancer.setCallback(this);
        return enhancer.create();
     }

    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        System.out.println("method callback start");
        // invoke方法有两个参数 Object obj, Object··· args
        // 这里的Object 是我们要执行的目标类，而不是intercept这个方法中的第一个参数，如果使用错，则会出现循环调用
        Object invoke = method.invoke(target, objects);
        System.out.println("method callback start");
        return invoke;
    }
      #+END_SRC

*** 注意
    
    在Spring的AOP编程中:

    如果加入容器的目标对象有实现接口,用JDK代理

    如果目标对象没有实现接口,用Cglib代理

** 复合模式 Compound

   MVC

** 桥接模式 Bridge 

*** 概念

    桥梁模式是对象的结构模式。又称为柄体(Handle and Body)模式或接口(Interface)模式。桥梁模式的用意是“将抽象化(Abstraction)与实现化(Implementation)脱耦，使得二者可以独立地变化”。

*** 用意

    桥梁模式虽然不是一个使用频率很高的模式，但是熟悉这个模式对于理解面向对象的设计原则，包括“开-闭”原则以及组合/聚合复用原则都很有帮助。理解好这两个原则，有助于形成正确的设计思想和培养良好的设计风格。

　　桥梁模式的用意是“将抽象化(Abstraction)与实现化(Implementation)脱耦，使得二者可以独立地变化”。这句话很短，但是第一次读到这句话的人很可能都会思考良久而不解其意。

　　这句话有三个关键词，也就是抽象化、实现化和脱耦。理解这三个词所代表的概念是理解桥梁模式用意的关键。

    1. 抽象化

       通常情况下，一组对象如果具有相同的特征，那么它们就可以通过一个共同的类来描述。如果一些类具有相同的特征，往往可以通过一个共同的抽象类来描述。

    2. 实现化

       抽象化给出的具体实现，就是实现化。

    　 一个类的实例就是这个类的实例化，一个具体子类是它的抽象超类的实例化。

    3. 脱耦

       所谓耦合，就是两个实体的行为的某种强关联。而将它们的强关联去掉，就是耦合的解脱，或称脱耦。在这里，脱耦是指将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联。

    　 所谓强关联，就是在编译时期已经确定的，无法在运行时期动态改变的关联；所谓弱关联，就是可以动态地确定并且可以在运行时期动态地改变的关联。显然, ~在Java语言中，继承关系是强关联，而聚合关系是弱关联。~

    　 将两个角色之间的继承关系改为聚合关系，就是将它们之间的强关联改换成为弱关联。因此，桥梁模式中的所谓脱耦，就是指在一个软件系统的抽象化和实现化之间使用聚合关系而不是继承关系，从而使两者可以相对独立地变化。这就是桥梁模式的用意。
    
*** 桥接模式的结构

**** 等级结构

     1. 由抽象化角色和修正抽象化角色组成的抽象化等级结构。

　　 2. 由实现化角色和两个具体实现化角色所组成的实现化等级结构。

**** 涉及角色

     1. 抽象化(Abstraction)角色：抽象化给出的定义，并保存一个对实现化对象的引用。

     2. 修正抽象化(RefinedAbstraction)角色：扩展抽象化角色，改变和修正父类对抽象化的定义。

　　 3. 实现化(Implementor)角色：这个角色给出实现化角色的接口，但不给出具体的实现。必须指出的是，这个接口不一定和抽象化角色的接口定义相同，实际上，这两个接口可以非常不一样。

        实现化角色应当只给出底层操作，而抽象化角色应当只给出基于底层操作的更高一层的操作。

　　 4. 具体实现化(ConcreteImplementor)角色：这个角色给出实现化角色接口的具体实现。

     ~注意~ 一般而言，实现化角色中的每个方法都应当有一个抽象化角色中的某一个方法与之对应，但是反过来则不一定。换言之，抽象化角色的接口比实现化角色的接口宽。抽象化角色除了提供与实现化角色相关的方法之外，还有可能提供其他的方法；
     
     而实现化角色则往往仅为实现抽象化角色的相关行为而存在。

**** 桥梁模式的优点

　　1. 分离抽象和实现部分

　　   桥梁模式分离了抽象部分和实现部分，从而极大地提供了系统的灵活性。让抽象部分和实现部分独立出来，分别定义接口，这有助于对系统进行分层，从而产生更好的结构化的系统。

　　2. 更好的扩展性

　　   桥梁模式使得抽象部分和实现部分可以分别独立地扩展，而不会相互影响，从而大大提高了系统的可扩展性。

**** 桥梁模式在Java中的使用
     
　　桥梁模式在Java应用中的一个非常典型的例子就是JDBC驱动器。JDBC为所有的关系型数据库提供一个通用的界面。一个应用系统动态地选择一个合适的驱动器，然后通过驱动器向数据库引擎发出指令。这个过程就是将抽象角色的行为委派给实现角色的过程。

　　抽象角色可以针对任何数据库引擎发出查询指令，因为抽象角色并不直接与数据库引擎打交道，JDBC驱动器负责这个底层的工作。由于JDBC驱动器的存在，应用系统可以不依赖于数据库引擎的细节而独立地演化；

    同时数据库引擎也可以独立于应用系统的细节而独立的演化。两个独立的等级结构如下图所示，左边是JDBC API的等级结构，右边是JDBC驱动器的等级结构。应用程序是建立在JDBC API的基础之上的。

** 生成器模式 Builder
   
*** 简介

    采用Builder模式来构建复杂的对象，通常会对Builder模式进行一定的简化，因为目标明确，就是创建某个复杂对象，因此做适当简化会使程序更简洁。大致简化如下：

    1. 由于是用Builder模式来创建某个对象，因此就没有必要再定义一个Builder接口，直接提供一个具体的构建器类就可以了。

    2. 对于创建一个负责的对象，可能会有很多种不同的选择和步骤，干脆去掉“指导者”，把指导者的功能和Client的功能合并起来，也就是说，Client就相当于指导者，它来指导构建器类去构建需要的复杂对象。

*** 生成器模式的优点

**** 松散耦合

     生成器模式可以用同一个构建算法构建出表现上完全不同的产品，实现产品构建和产品表现上的分离。生成器模式正是把产品构建的过程独立出来，使它和具体产品的表现分松散耦合，从而使得构建算法可以复用，
     而具体产品表现也可以很灵活地、方便地扩展和切换。

     可以很容易的改变产品的内部表示

     在生成器模式中，由于Builder对象只是提供接口给Director使用，那么具体部件创建和装配方式是被Builder接口隐藏了的，Director并不知道这些具体的实现细节。这样一来，要想改变产品的内部表示，
     只需要切换Builder接口的具体实现即可，不用管Director，因此变得很容易。

**** 更好的复用性

     生成器模式很好的实现构建算法和具体产品实现的分离。这样一来，使得构建产品的算法可以复用。同样的道理，具体产品的实现也可以复用，同一个产品的实现，可以配合不同的构建算法使用。



*** 生成器模式的本质

    ~分离整体构建算法和部件构造。~

    虽然在生成器模式的整体构建算法中，会一步一步引导Builder来构建对象，但这并不是说生成器主要就是用来实现分步骤构建对象的。 ~生成器模式的重心还是在于分离整体构建算法和部件构造，~
    而分步骤构建对象不过是整体构建算法的一个简单表现，或者说是一个附带产物。

*** 何时选用生成器模式

    建议在以下情况中选用生成器模式。

    如果创建对象的算法，应该独立于该对象的组成部分以及它们的装配方式时。

    如果同一个构建过程有着不同的表示时。

** 责任链模式 Chain of Responsibility

*** 概念

    *责任链模式是一种对象的行为模式。* 在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。
    发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。

*** 结构图示

    [[file:./java-design-patterns/media/image1.png]]

*** 结构说明

    1. 抽象处理者(Handler)角色

       定义出一个处理请求的接口。如果需要，接口可以定义 出一个方法以设定和返回对下家的引用。这个角色通常由一个Java抽象类或者Java接口实现。
       上图中Handler类的聚合关系给出了具体子类对下家的引用，抽象方法handleRequest()规范了子类处理请求的操作。

　　2. 具体处理者(ConcreteHandler)角色：具体处理者接到请求后，可以选择将请求处理掉，或者将请求传给下家。由于具体处理者持有对下家的引用，因此，如果需要，具体处理者可以访问下家。

*** 纯与不纯的责任链

**** 纯

     一个纯的责任链模式要求一个具体的处理者对象只能在两个行为中选择一个：一是承担责任，二是把责任推给下家。 *不允许出现某一个具体处理者对象在承担了一部分责任后又把责任向下传的情况。*

     在一个纯的责任链模式里面，一个请求必须被某一个处理者对象所接收；

**** 不纯

     在一个不纯的责任链模式里面，一个请求可以最终不被任何接收端对象所接收。

*** 使用的案例

    1. tomcat

    2. Spring security中的过滤器链

** 蝇量模式 FlyWeight

*** 概念

    也称之为 “享元模式”，享元模式是对象的结构模式。享元模式以共享的方式高效地支持大量的细粒度对象。

    ~可以简单理解为：对象小但是数量多的对象，可以减少new对象，而采用方法中传参数的方式解决~

*** Java中的String类型

    在JAVA语言中，String类型就是使用了享元模式。

    ~String对象是final类型，对象一旦创建就不可改变。在JAVA中字符串常量都是存在常量池中的，JAVA会确保一个字符串常量在常量池中只有一个拷贝。String a="abc"，其中"abc"就是一个字符串常量。~

*** 享元模式的结构

    享元模式采用一个共享来避免大量拥有相同内容对象的开销。这种开销最常见、最直观的就是内存的损耗。享元对象能做到共享的关键是区分内蕴状态(Internal State)和外蕴状态(External State)。

　　一个内蕴状态是存储在享元对象内部的，并且是不会随环境的改变而有所不同。因此，一个享元可以具有内蕴状态并可以共享。 ~可以理解为是new一个对象~

　　一个外蕴状态是随环境的改变而改变的、不可以共享的。 *享元对象的外蕴状态必须由客户端保存* ，并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。外蕴状态不可以影响享元对象的内蕴状态，它们是相互独立的。
    ~就是具体对象方法中需要表现出来的参数~

*** 两种享元模式

**** 单纯享元模式

     ~在单纯的享元模式中，所有的享元对象都是可以共享的。~

     1. 抽象享元(Flyweight)角色 ：给出一个抽象接口，以规定出所有具体享元角色需要实现的方法。

     2. 具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定出的接口。如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。

     3. 享元工厂(FlyweightFactory)角色 ：本角色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享。当一个客户端对象调用一个享元对象的时候，享元工厂角色会检查系统中是否已经有一个符合要求的享元对象。

     如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有一个适当的享元对象的话，享元工厂角色就应当创建一个合适的享元对象。

**** 复合享元模式

     在单纯享元模式中，所有的享元对象都是单纯享元对象，也就是说都是可以直接共享的。还有一种较为复杂的情况，将一些单纯享元使用合成模式加以复合，形成复合享元对象。

     ~这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享。~

     1. 抽象享元(Flyweight)角色 ：给出一个抽象接口，以规定出所有具体享元角色需要实现的方法。

     2. 具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定出的接口。如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。

     3. 复合享元(ConcreteCompositeFlyweight)角色 ：复合享元角色所代表的对象是不可以共享的，但是一个复合享元对象可以分解成为多个本身是单纯享元对象的组合。复合享元角色又称作不可共享的享元对象。

     4. 享元工厂(FlyweightFactory)角色 ：本角 色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享。当一个客户端对象调用一个享元对象的时候，享元工厂角色会检查系统中是否已经有 一个符合要求的享元对象。
        如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有一个适当的享元对象的话，享元工厂角色就应当创建一个 合适的享元对象。

** 解释器模式 Interpreter Pattern

*** 核心概念

    定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码。 *解释器模式是一种类行为型模式。*

*** 结构中的重要组成部分

    1. 抽象表达式(Expression)

       声明一个所有的具体表达式角色都需要实现的抽象接口。这个接口主要是一个interpret()方法，称做解释操作。

    2. 终结符表达式(Terminal Expression)

       实现了抽象表达式角色所要求的接口，主要是一个interpret()方法；文法中的每一个终结符都有一个具体终结表达式与之相对应。比如有一个简单的公式R=R1+R2，在里面R1和R2就是终结符，对应的解析R1和R2的解释器就是终结符表达式。

    3. 非终结符表达式(Nonterminal Expression)

       文法中的每一条规则都需要一个具体的非终结符表达式，非终结符表达式一般是文法中的运算符或者其他关键字，比如公式R=R1+R2中，“+”就是非终结符，解析“+”的解释器就是一个非终结符表达式。

    4. 环境(Context)角色

       这个角色的任务一般是用来存放文法中各个终结符所对应的具体值，比如R=R1+R2，我们给R1赋值100，给R2赋值200。这些信息需要存放到环境角色中，很多情况下我们使用Map来充当环境角色就足够了

       在这个语言中终结符是布尔变量，也就是常量true和false。非终结符表达式包含运算符and、or和not等布尔表达式。这个简单的文法如下：

    | Name       | desc                                 |
    |------------+--------------------------------------|
    | Expression | Constant , Variable , Or , And , Not |
    | And        | Expression 'AND' Expression          |
    | Or         | Expression 'OR' Expression           |
    | Not        | 'NOT' Expression                     |
    | Variable   | 任何标识符                           |
    | Constant   | 'true' , 'false'                     |

*** 解释器模式优点：

    1. 易于改变和扩展文法。

    2. 每一条 *文法规则* 都可以表示为一个类，因此可以方便地实现一个简单的语言。

    3. 实现文法较为容易。在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂，还可以通过一些工具自动生成节点类代码。

    4. 增加新的解释表达式较为方便。如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合“开闭原则”。

*** 解释器模式缺点：

    对于复杂文法难以维护。 *在解释器模式中，每一条规则至少需要定义一个类* ，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护，此时可以考虑使用语法分析程序等方式来取代解释器模式。

    执行效率较低。由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦。

** 中介者模式 Mediator

*** 概念

    用一个中介者对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使耦合松散，而且可以独立地改变它们之间的交互。 ~行为类模式~

    ~其实就是将相关联的类的影响行为，抽取出来成一个单独的类进行处理。~

*** 结构

    1. 抽象中介者：定义好同事类对象到中介者对象的接口，用于各个同事类之间的通信。一般包括一个或几个抽象的事件方法，并由子类去实现。

    2. 中介者实现类：从抽象中介者继承而来，实现抽象中介者中定义的事件方法。从一个同事类接收消息，然后通过消息影响其他同时类。

    3. 同事类：如果一个对象会影响其他的对象，同时也会被其他对象影响，那么这两个对象称为同事类。在类图中，同事类只有一个，这其实是现实的省略，

    在实际应用中，同事类一般由多个组成，他们之间相互影响，相互依赖。同事类越多，关系越复杂。并且，同事类也可以表现为继承了同一个抽象类的一组实现组成。在中介者模式中，同事类之间必须通过中介者才能进行消息传递。

*** 中介者模式的优点

    1. 适当地使用中介者模式可以避免同事类之间的过度耦合，使得各同事类之间可以相对独立地使用。

    2. 使用中介者模式可以将对象间一对多的关联转变为一对一的关联，使对象间的关系易于理解和维护。

    3. 使用中介者模式可以将对象的行为和协作进行抽象，能够比较灵活的处理对象间的相互作用。

*** 适用场景

    在面向对象编程中，一个类必然会与其他的类发生依赖关系，完全独立的类是没有意义的。

    一个类同时依赖多个类的情况也相当普遍，既然存在这样的情况，说明，一对多的依赖关系有它的合理性， *适当的使用中介者模式可以使原本凌乱的对象关系清晰* ，但是如果滥用，则可能会带来反的效果。

    *一般来说，只有对于那种同事类之间是网状结构的关系，才会考虑使用中介者模式。* 可以将网状结构变为星状结构，使同事类之间的关系变的清晰一些。

    中介者模式是一种比较常用的模式，也是一种比较容易被滥用的模式。对于大多数的情况，同事类之间的关系不会复杂到混乱不堪的网状结构，

    因此，大多数情况下，将对象间的依赖关系封装的同事类内部就可以的，没有必要非引入中介者模式。滥用中介者模式，只会让事情变的更复杂

** 备忘录模式

*** 概念

    在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态   行为类模型

*** 图示介绍

    [[file:./java-design-patterns/media/image2.png]]

     我们在编程的时候，经常需要保存对象的中间状态，当需要的时候，可以恢复到这个状态。比如，我们使用Eclipse进行编程时，假如编写失误（例如不小心误删除了几行代码），我们希望返回删除前的状态，

     便可以使用Ctrl+Z来进行返回。这时我们便可以使用备忘录模式来实现。

*** 结构

    1. 发起人 =Originator= ：记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录数据。

    2. 备忘录 =Memento= ：负责存储发起人对象的内部状态，在需要的时候提供发起人需要的内部状态。

    3. 管理角色 =Caretaker= ：对备忘录进行管理，保存和提供备忘录。

*** 备忘录模式的优点有：

    当发起人角色中的状态改变时，有可能这是个错误的改变，我们使用备忘录模式就可以把这个错误的改变还原。

    备份的状态是保存在发起人角色之外的，这样，发起人角色就不需要对各个备份的状态进行管理。

*** 备忘录模式的缺点：

    在实际应用中，备忘录模式都是多状态和多备份的，发起人角色的状态需要存储到备忘录对象中，对资源的消耗是比较严重的。

*** 应用场景

    如果有需要提供回滚操作的需求，使用备忘录模式非常适合，比如jdbc的事务操作，文本编辑器的Ctrl+Z恢复等

** 原型模式 Prototype

*** 概念 

    定义：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。 *创建类模式*

*** 核心条件

    原型模式主要用于对象的复制，它的核心是就是类图中的原型类Prototype。Prototype类需要具备以下两个条件：

    1. 实现Cloneable接口。在java语言有一个Cloneable接口，它的作用只有一个，就是在运行时通知虚拟机可以安全地在实现了此接口的类上使用clone方法。
       *在java虚拟机中，只有实现了这个接口的类才可以被拷贝，否则在运行时会抛出CloneNotSupportedException异常。*

    2. 重写Object类中的clone方法。Java中，所有类的父类都是Object类，Object类中有一个clone方法，作用是返回对象的一个拷贝， ~但是其作用域protected类型的，一般的类无法调用，因此，Prototype类需要将clone方法的作用域修改为public类型。~ 

    原型模式是一种比较简单的模式，也非常容易理解，实现一个接口，重写一个方法即完成了原型模式。在实际应用中，原型模式很少单独出现。经常与其他模式混用，他的原型类Prototype也常用抽象类来替代。

*** 原型模式的优点及适用场景

    1. 使用原型模式创建对象比直接new一个对象在性能上要好的多， ~因为Object类的clone方法是一个本地方法，它直接操作内存中的二进制流，特别是复制大对象时，性能的差别非常明显。~

    2. 使用原型模式的另一个好处是简化对象的创建，使得创建对象就像我们在编辑文档时的复制粘贴一样简单。

    因为以上优点，所以在需要重复地创建相似对象时可以考虑使用原型模式。比如需要在一个循环体内创建对象，假如对象创建过程比较复杂或者循环次数很多的话，使用原型模式不但可以简化创建过程，而且可以使系统的整体性能提高很多。

*** 原型模式的注意事项

    ~使用原型模式复制对象不会调用类的构造方法。因为对象的复制是通过调用Object类的clone方法来完成的，它直接在内存中复制数据，因此不会调用到类的构造方法。~

    不但构造方法中的代码不会执行，甚至连访问权限都对原型模式无效。还记得单例模式吗？单例模式中，只要将构造方法的访问权限设置为private型，就可以实现单例。

    但是clone方法直接无视构造方法的权限，所以，单例模式与原型模式是冲突的，在使用时要特别注意。

    深拷贝与浅拷贝。Object类的clone方法只会拷贝对象中的基本的数据类型，对于数组、容器对象、引用对象等都不会拷贝，这就是浅拷贝。如果要实现深拷贝，必须将原型模式中的数组、容器对象、引用对象等另行拷贝。例如：

    #+BEGIN_SRC java
      public class Prototype implements Cloneable {
        private ArrayList list = new ArrayList();
        public Prototype clone(){
          Prototype prototype = null;
          try{
            prototype = (Prototype)super.clone();
            prototype.list = (ArrayList) this.list.clone();
          }catch(CloneNotSupportedException e){
            e.printStackTrace();
          }
          return prototype; 
        }
      }
    #+END_SRC
    
    ~由于ArrayList不是基本类型，所以成员变量list，不会被拷贝，需要我们自己实现深拷贝，幸运的是java提供的大部分的容器类都实现了Cloneable接口。所以实现深拷贝并不是特别困难。~

    PS：深拷贝与浅拷贝问题中，会发生深拷贝的有java中的8中基本类型以及他们的封装类型，另外还有String类型。其余的都是浅拷贝

** 访问者模式 Visitor

*** 概念 

    访问者模式(Visitor Pattern)模式是行为型(Behavioral)设计模式，提供一个作用于某种对象结构上的各元素的操作方式，可以使我们在不改变元素结构的前提下，定义作用于元素的新操作。

    换言之，如果系统的数据结构是比较稳定的，但其操作（算法）是易于变化的，那么使用访问者模式是个不错的选择；如果数据结构是易于变化的，则不适合使用访问者模式。

*** 结构

    1. Vistor（抽象访问者）：为该对象结构中具体元素角色声明一个访问操作接口。

    2. ConcreteVisitor（具体访问者）：每个具体访问者都实现了Vistor中定义的操作。

    3. Element（抽象元素）：定义了一个accept操作，以Visitor作为参数。

    4. ConcreteElement（具体元素）：实现了Element中的accept()方法，调用Vistor的访问方法以便完成对一个元素的操作。

    5. ObjectStructure（对象结构）：可以是组合模式，也可以是集合；能够枚举它包含的元素；提供一个接口，允许Vistor访问它的元素。

*** 总结

    如果一个对象结构比较复杂，同时结构稳定不易变化，但却需要经常在此结构上定义新的操作，那就非常合适使用访问者模式，比如复杂的集合对象、XML文档解析、编译器的设计等。
    
    访问者模式使我们更加容易的增加访问操作，但增加元素比较困难，需要我们修改抽象访问类和所有的具体访问类。

